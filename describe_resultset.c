/*
 * describe_resultset.c
 *
 *
 * Extension describe_resultset
 *
 * Returns the description of the result set generated by the supplied query.
 * Nick Ivanov <nick.ivanov@enterprisedb.com>
 *
 * # Copyright (c) 2023 EnterpriseDB Corporation.  All rights reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */

#include "postgres.h"

#include "access/htup_details.h"
#include "catalog/pg_type.h"
#include "executor/spi.h"
#include "executor/spi_priv.h"  // we want to use SPIPlanPtr internals
#include "funcapi.h"
#include "miscadmin.h"
#include "utils/builtins.h"
#include "describe_resultset.h"

PG_MODULE_MAGIC;

/* TODO support for parameterised statements */
PG_FUNCTION_INFO_V1(describe_resultset);
Datum
describe_resultset(PG_FUNCTION_ARGS)
{
    /* The function is declared STRICT, no need to check PG_ARGISNULL */
    char	        *sql = text_to_cstring(PG_GETARG_TEXT_PP(0));
    ReturnSetInfo   *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;
    Tuplestorestate *tupstore;
    TupleDesc	    tupdesc;
    SPIPlanPtr      plan_ptr;
    MemoryContext   per_query_ctx;
    MemoryContext   oldcontext;

    ListCell        *lc1;
    int             ret;

    /* check to see if caller supports us returning a tuplestore */
    if (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))
        ereport(ERROR,
                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                 errmsg("set-valued function called in context that cannot accept a set")));
    if (!(rsinfo->allowedModes & SFRM_Materialize))
        ereport(ERROR,
                (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                 errmsg("materialize mode required, but it is not allowed in this context")));

    /* get a tuple descriptor for our result type */
    switch (get_call_result_type(fcinfo, NULL, &tupdesc))
    {
        case TYPEFUNC_COMPOSITE:
            /* success */
            break;
        case TYPEFUNC_RECORD:
            /* failed to determine actual type of RECORD */
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));
            break;
        default:
            /* result type isn't composite */
            ereport(ERROR,
                    (errcode(ERRCODE_DATATYPE_MISMATCH),
                     errmsg("return type must be a row type")));
            break;
    }

    per_query_ctx = rsinfo->econtext->ecxt_per_query_memory;

	/* Connect to the SPI manager */
	if ((ret = SPI_connect()) < 0)
		/* internal error */
		elog(ERROR, "describe_resultset: SPI_connect returned %d", ret);

    /* we might pass query parameters in the future */
    plan_ptr = SPI_prepare(sql, 0, NULL);

    if (plan_ptr->oneshot)
        /* one-shot plan, needs extra processing */
		elog(ERROR, "describe_resultset: oneshot plan, no go");

	/* switch to long-lived memory context */
	oldcontext = MemoryContextSwitchTo(per_query_ctx);

	/* finalise the tuple descriptor */
	tupdesc = BlessTupleDesc(tupdesc);

	/* initialize our tuplestore in long-lived context */
	tupstore = tuplestore_begin_heap(false, false, work_mem);

	MemoryContextSwitchTo(oldcontext);

    foreach(lc1, plan_ptr->plancache_list)
	{
        int i;
        HeapTuple tuple;
		CachedPlanSource *plansource = (CachedPlanSource *) lfirst(lc1);
        TupleDesc res_desc = CreateTupleDescCopy(plansource->resultDesc);
        /* loop over the query result attributes */
        for (i=0; i<res_desc->natts; i++) {
            Datum values[4];
            bool  nulls[4] = {false, false, false, true};
            values[0] = NameGetDatum(&(res_desc->attrs[i].attname));
            values[1] = ObjectIdGetDatum(res_desc->attrs[i].atttypid);
            values[2] = Int16GetDatum(res_desc->attrs[i].attlen);
            values[3] = (Datum)NULL; /* TODO */
            /* Build and store a tuple */
            tuple = heap_form_tuple(tupdesc, values, nulls);
            tuplestore_puttuple(tupstore, tuple);
            heap_freetuple(tuple);
        }
    }
    /* let the caller know we're sending back a tuplestore */
    rsinfo->returnMode = SFRM_Materialize;
    rsinfo->setResult = tupstore;
    rsinfo->setDesc = tupdesc;

    /* release SPI related resources (and return to caller's context) */
    SPI_finish();

    return (Datum) 0;
}